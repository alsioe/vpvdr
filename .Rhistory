}
#' Summarises data by subject (not group)
#'
#' @param list
#'
#' @return Data frame with session data for each subject and trial type
#' @export
#'
#' @examples
summarise_correct_by_subj <- function(list,
groups = 1:length(unique(list$grouping))
) {
nSubj <- length(list$subjID)
nGroups <- length(unique(list$grouping))
nTrials <- length(list$trial)
df <- data.frame(
subjID = sort(rep(x = unique(list$subjID),
times = nTrials)
),
grouping = sort(rep(x = unique(list$grouping),
times = nSubj / nGroups * nTrials)
),
trial = rep(x = 1:nTrials,
times = nSubj),
stim_left = rep(x = list$stim_left,
times = nSubj),
stim_right = rep(x = list$stim_right,
times = nSubj),
p_right = c(list$p_right),
chose_right = c(list$chose_right),
outcome = c(list$outcome)
)
# Enter trial type
df$trial_type <- df$stim_left + df$stim_right
df$trial_type[df$trial_type == 50] <- 'neg'
df$trial_type[df$trial_type == 100] <- 'vd'
df$trial_type[df$trial_type == 150] <- 'pos'
# Enter choice of stimulus
df$choice <- NA
df$choice[df$chose_right == 0] <-
df$stim_left[df$chose_right == 0]
df$choice[df$chose_right == 1] <-
df$stim_right[df$chose_right == 1]
# Enter correct; remember '50' is correct on 'neg' trials (0 vs. 50)
df$correct <- FALSE
df$correct[df$trial_type == 'neg'] <-
df$choice[df$trial_type == 'neg'] == 50
df$correct[df$trial_type == 'vd'] <-
df$choice[df$trial_type == 'vd'] == 100
df$correct[df$trial_type == 'pos'] <-
df$choice[df$trial_type == 'pos'] == 100
# Enter session
df$session <- NA
df$session <- ceiling(df$trial / 200)
# Turn into factors
df$trial_type <- factor(x = df$trial_type,
levels = c('vd',
'pos',
'neg')
)
df$subjID <- as.factor(df$subjID)
df$grouping <- factor(x = df$grouping,
labels = groups)
#RETURN
df %>%
group_by(session,
trial_type,
subjID,
grouping) %>%
summarise(correct = mean(correct))
}
nIter <- 100 # number of samples per condition
nGroups <- 3 # number of conditions
nTrials <- 2800 # number of trials of VPVD (200 per session)
?simulate_choices_vpvd
simulated_rats <- simulate_choices_vpvd(nTrials = nTrials,
nIter = nIter,
nGroups = nGroups,
alpha_w = c(rep(0.002, nIter),
rep(0.004, nIter),
rep(0.006, nIter)
),
alpha_l = rep(0.002, nIter * nGroups),
beta = rep(2, nIter * nGroups),
kappa = rep(0.2, nIter * nGroups),
tau = rep(0.1, nIter * nGroups),
upsilon = rep(5, nIter * nGroups))
?summarise_correct_by_subj
df_subj <- summarise_correct_by_subj(simulated_rats)
df_group <- summarise_correct_by_group(df_subj)
# Let's plot that out in ggplot, using geom_ribbon() to visualise the 50% HDI
df_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
# If we really want to see the performance of each iteration, here's that.
df_subj %>%
ggplot(aes(x = session,
y = correct,
colour = subjID)) +
geom_line(alpha = 0.1) +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
theme(legend.position = 'NONE') +
scale_colour_manual(values = palette_by_group(nGroups = nGroups,
nIter = nIter))
palette_by_group <- function(nGroups, nIter) {
green_funct <- colorRampPalette(c('lightgreen','darkgreen'))
orange_funct <- colorRampPalette(c('orange', 'darkred'))
blue_funct <- colorRampPalette(c('lightblue', 'darkblue'))
purple_funct <- colorRampPalette(c('magenta', 'purple'))
gold_funct <- colorRampPalette(c('tan', 'gold'))
grey_funct <- colorRampPalette(c('lightgrey', 'black'))
list_of_colours <- vector(mode = 'character')
if (nGroups > 0) list_of_colours <- c(list_of_colours,
green_funct(nIter))
if (nGroups > 1) list_of_colours <- c(list_of_colours,
orange_funct(nIter))
if (nGroups > 2) list_of_colours <- c(list_of_colours,
blue_funct(nIter))
if (nGroups > 3) list_of_colours <- c(list_of_colours,
gold_funct(nIter))
if (nGroups > 4) list_of_colours <- c(list_of_colours,
purple_funct(nIter))
if (nGroups > 5) list_of_colours <- c(list_of_colours,
grey_funct(nIter))
# plot(rep(1,100), col=green_funct(100), pch=19, cex=3)
# plot(rep(1,100), col=orange_funct(100), pch=19, cex=3)
# plot(rep(1,100), col=blue_funct(100), pch=19, cex=3)
# plot(rep(1,100), col=purple_funct(100), pch=19, cex=3)
# plot(rep(1,100), col=gold_funct(100), pch=19, cex=3)
# plot(rep(1,100), col=grey_funct(100), pch=19, cex=3)
# Exclude this bit?
# structure(.Data = list_of_colours,
#           name = 'groupalette',
#           class = 'palette')
#
return(list_of_colours)
}
# If we really want to see the performance of each iteration, here's that.
df_subj %>%
ggplot(aes(x = session,
y = correct,
colour = subjID)) +
geom_line(alpha = 0.1) +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
theme(legend.position = 'NONE') +
scale_colour_manual(values = palette_by_group(nGroups = nGroups,
nIter = nIter))
# Next, let's take our actual posterior and feed that in to the simulator code.
nIter <- 1000 # a minimum of 1000 to get accurate posterior y's
nGroups <- 3
nTrials <- 2800
# Let's create a list of samples ('draws') from the posterior
# - this is to ensure that the the parameters we use for the simulation are
# all from the same iteration
draws <- sample(x = dim(group_params$reinf_sensitivity_by_group_drug)[1],
size = nIter,
replace = FALSE)
# This will be baked into a function at some point
w <- group_params$reward_rate_by_group_drug[draws, 1:nGroups, 1]
l <- group_params$punish_rate_by_group_drug[draws, 1:nGroups, 1]
b <- group_params$reinf_sensitivity_by_group_drug[draws, 1:nGroups, 1]
k <- group_params$side_stickiness_by_group_drug[draws, 1:nGroups, 1]
t <- group_params$stimulus_stickiness_by_group_drug[draws, 1:nGroups, 1]
u <- group_params$prob_discount_by_group_drug[draws, 1:nGroups, 1]
# Simulate all subjects in parallel
# nIter = 1000; groups = 3 takes <10 seconds over here
system.time(
post_pred_check <- simulate_choices_vpvd(nTrials = nTrials,
nGroups = nGroups,
nIter = nIter,
alpha_w = w,
alpha_l = l,
beta = b,
kappa = k,
tau = t,
upsilon = u)
)
# Again, this is a large list that needs to be deleted and
# we will do this automatically at some point
object.size(post_pred_check)/1048576 # outputs the size in MB
ppc_subj <- summarise_correct_by_subj(post_pred_check,
c('veh', 'low', 'high'))
ppc_group <- summarise_correct_by_group(ppc_subj)
# Same plot as above
ppc_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2,
show.legend = FALSE) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
list.files()
list.files('helper/')
fit <- readRDS("helper/2C_reversals_fit10.rds")
# Try this function
?get_posteriors
params <- get_posteriors(fit)
# Sanity check
# There are many parameters, but get_posteriors only pulls out the ones we need.
names(params$group_params)
names(params$subject_params)
# Let's make them into separate lists
group_params <- params$group_params
subject_params <- params$subject_params
# We have a 3 dimensional array for each parameter, where
# the 1st dimension is the number of SAMPLES in the posterior
# the 2nd dimension is the number of GROUPS (here, doses)
# the 3rd dimension is the number of within-subject levels (e.g. dose)
dim(group_params[[1]])
# We can visualise the grouped parameters for a reality check.
# Currently struggling to run this without separately loading the
# libraries/packages (tidyr, ggplot2, cowplot). They are all under
# dependencies in DESCRIPTION already so this needs some further testing.
?visual_posteriors
visual_posteriors(params = group_params,
grouping = c('veh', 'low', 'high')
)
fit
fit <- readRDS("helper/2A_reversals_fit10.rds")
fit <- readRDS("helper/2A_reversals_fit1.rds")
# Try this function
?get_posteriors
params <- get_posteriors(fit)
# Sanity check
# There are many parameters, but get_posteriors only pulls out the ones we need.
names(params$group_params)
names(params$subject_params)
# Let's make them into separate lists
group_params <- params$group_params
subject_params <- params$subject_params
# We have a 3 dimensional array for each parameter, where
# the 1st dimension is the number of SAMPLES in the posterior
# the 2nd dimension is the number of GROUPS (here, doses)
# the 3rd dimension is the number of within-subject levels (e.g. dose)
dim(group_params[[1]])
# We can visualise the grouped parameters for a reality check.
# Currently struggling to run this without separately loading the
# libraries/packages (tidyr, ggplot2, cowplot). They are all under
# dependencies in DESCRIPTION already so this needs some further testing.
?visual_posteriors
visual_posteriors(params = group_params,
grouping = c('veh', 'low', 'high')
)
nIter <- 100 # number of samples per condition
nGroups <- 3 # number of conditions
nTrials <- 2800 # number of trials of VPVD (200 per session)
?simulate_choices_vpvd
simulated_rats <- simulate_choices_vpvd(nTrials = nTrials,
nIter = nIter,
nGroups = nGroups,
alpha_w = c(rep(0.002, nIter),
rep(0.004, nIter),
rep(0.006, nIter)
),
alpha_l = rep(0.002, nIter * nGroups),
beta = rep(2, nIter * nGroups),
kappa = rep(0.2, nIter * nGroups),
tau = rep(0.1, nIter * nGroups),
upsilon = rep(5, nIter * nGroups))
?summarise_correct_by_subj
df_subj <- summarise_correct_by_subj(simulated_rats)
df_group <- summarise_correct_by_group(df_subj)
# Let's plot that out in ggplot, using geom_ribbon() to visualise the 50% HDI
df_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
# If we really want to see the performance of each iteration, here's that.
df_subj %>%
ggplot(aes(x = session,
y = correct,
colour = subjID)) +
geom_line(alpha = 0.1) +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
theme(legend.position = 'NONE') +
scale_colour_manual(values = palette_by_group(nGroups = nGroups,
nIter = nIter))
# Next, let's take our actual posterior and feed that in to the simulator code.
nIter <- 1000 # a minimum of 1000 to get accurate posterior y's
nGroups <- 3
nTrials <- 2800
# Let's create a list of samples ('draws') from the posterior
# - this is to ensure that the the parameters we use for the simulation are
# all from the same iteration
draws <- sample(x = dim(group_params$reinf_sensitivity_by_group_drug)[1],
size = nIter,
replace = FALSE)
# This will be baked into a function at some point
w <- group_params$reward_rate_by_group_drug[draws, 1:nGroups, 1]
l <- group_params$punish_rate_by_group_drug[draws, 1:nGroups, 1]
b <- group_params$reinf_sensitivity_by_group_drug[draws, 1:nGroups, 1]
k <- group_params$side_stickiness_by_group_drug[draws, 1:nGroups, 1]
t <- group_params$stimulus_stickiness_by_group_drug[draws, 1:nGroups, 1]
u <- group_params$prob_discount_by_group_drug[draws, 1:nGroups, 1]
# Simulate all subjects in parallel
# nIter = 1000; groups = 3 takes <10 seconds over here
system.time(
post_pred_check <- simulate_choices_vpvd(nTrials = nTrials,
nGroups = nGroups,
nIter = nIter,
alpha_w = w,
alpha_l = l,
beta = b,
kappa = k,
tau = t,
upsilon = u)
)
# Again, this is a large list that needs to be deleted and
# we will do this automatically at some point
object.size(post_pred_check)/1048576 # outputs the size in MB
ppc_subj <- summarise_correct_by_subj(post_pred_check,
c('veh', 'low', 'high'))
ppc_group <- summarise_correct_by_group(ppc_subj)
# Same plot as above
ppc_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2,
show.legend = FALSE) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
fit <- readRDS("helper/reversals_fit10.rds")
# Try this function
?get_posteriors
params <- get_posteriors(fit)
# Sanity check
# There are many parameters, but get_posteriors only pulls out the ones we need.
names(params$group_params)
names(params$subject_params)
# Let's make them into separate lists
group_params <- params$group_params
subject_params <- params$subject_params
# We have a 3 dimensional array for each parameter, where
# the 1st dimension is the number of SAMPLES in the posterior
# the 2nd dimension is the number of GROUPS (here, doses)
# the 3rd dimension is the number of within-subject levels (e.g. dose)
dim(group_params[[1]])
# We can visualise the grouped parameters for a reality check.
# Currently struggling to run this without separately loading the
# libraries/packages (tidyr, ggplot2, cowplot). They are all under
# dependencies in DESCRIPTION already so this needs some further testing.
?visual_posteriors
visual_posteriors(params = group_params,
grouping = c('veh', 'low', 'high')
)
nIter <- 100 # number of samples per condition
nGroups <- 3 # number of conditions
nTrials <- 2800 # number of trials of VPVD (200 per session)
?simulate_choices_vpvd
simulated_rats <- simulate_choices_vpvd(nTrials = nTrials,
nIter = nIter,
nGroups = nGroups,
alpha_w = c(rep(0.002, nIter),
rep(0.004, nIter),
rep(0.006, nIter)
),
alpha_l = rep(0.002, nIter * nGroups),
beta = rep(2, nIter * nGroups),
kappa = rep(0.2, nIter * nGroups),
tau = rep(0.1, nIter * nGroups),
upsilon = rep(5, nIter * nGroups))
?summarise_correct_by_subj
df_subj <- summarise_correct_by_subj(simulated_rats)
df_group <- summarise_correct_by_group(df_subj)
# Let's plot that out in ggplot, using geom_ribbon() to visualise the 50% HDI
df_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
# If we really want to see the performance of each iteration, here's that.
df_subj %>%
ggplot(aes(x = session,
y = correct,
colour = subjID)) +
geom_line(alpha = 0.1) +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
theme(legend.position = 'NONE') +
scale_colour_manual(values = palette_by_group(nGroups = nGroups,
nIter = nIter))
# Next, let's take our actual posterior and feed that in to the simulator code.
nIter <- 1000 # a minimum of 1000 to get accurate posterior y's
nGroups <- 3
nTrials <- 2800
# Let's create a list of samples ('draws') from the posterior
# - this is to ensure that the the parameters we use for the simulation are
# all from the same iteration
draws <- sample(x = dim(group_params$reinf_sensitivity_by_group_drug)[1],
size = nIter,
replace = FALSE)
# This will be baked into a function at some point
w <- group_params$reward_rate_by_group_drug[draws, 1:nGroups, 1]
l <- group_params$punish_rate_by_group_drug[draws, 1:nGroups, 1]
b <- group_params$reinf_sensitivity_by_group_drug[draws, 1:nGroups, 1]
k <- group_params$side_stickiness_by_group_drug[draws, 1:nGroups, 1]
t <- group_params$stimulus_stickiness_by_group_drug[draws, 1:nGroups, 1]
u <- group_params$prob_discount_by_group_drug[draws, 1:nGroups, 1]
# Simulate all subjects in parallel
# nIter = 1000; groups = 3 takes <10 seconds over here
system.time(
post_pred_check <- simulate_choices_vpvd(nTrials = nTrials,
nGroups = nGroups,
nIter = nIter,
alpha_w = w,
alpha_l = l,
beta = b,
kappa = k,
tau = t,
upsilon = u)
)
# Again, this is a large list that needs to be deleted and
# we will do this automatically at some point
object.size(post_pred_check)/1048576 # outputs the size in MB
ppc_subj <- summarise_correct_by_subj(post_pred_check,
c('veh', 'low', 'high'))
ppc_group <- summarise_correct_by_group(ppc_subj)
# Same plot as above
ppc_group %>%
ggplot(aes(x = session,
y = mean,
colour = grouping)) +
geom_ribbon(aes(ymin = q.250,
ymax = q.750,
fill = grouping,
colour = NA),
alpha = 0.2,
show.legend = FALSE) +
geom_line() +
facet_grid(. ~ trial_type) +
ylim(0, 1) +
geom_hline(yintercept = 0.5,
linetype = 'dashed') +
theme_bw() +
scale_color_brewer(palette = 'Dark2') +
scale_fill_brewer(palette = 'Dark2')
